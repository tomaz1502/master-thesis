\subsection{Description of the Problem}

The Boolean Satisfiability Problem (SAT) consists of, given a formula in Propositional Logic (PL) containing free variables, determine whether exists a function that assigns each variable to a boolean value, in a way that, after replacing the variables by their values provided by the function, the formula is evaluated to \textit{true}. We say that a formula is satisfiable if such function exists, and unsatisfiable otherwise. In this work, we will be focusing on the problem CNF-SAT, an equivalent version of SAT in which the input formula always comes in Conjuctive Normal Form, that is, a conjunction of disjunctions. From now on, we will use SAT to refer to the CNF-SAT problem. Besides that, we will use the name \textit{clause} to refer to one of the disjunctions in some input formula for SAT.

Satisfiability Modulo Theories (SMT)~\cite{smt} is a generalization of SAT.\ There are two additions in this version of the problem: the first one is that the input formula can contain quantifiers binding variables, which will affect the satisfiability of that formula. Therefore, any formula in First Order Logic is a valid input to the SMT problem. The second addition is the inclusion of a set of theories that allows the problem to refer to variables of different domains. More precisely, a theory consists of a sort (for instance, integers) over which a subset of the variables of the problem can range over and a set of symbols that represents operations over these sorts with predefined semantics (for instance, addition and comparison operations). SMT problems are allowed to use multiple theories in the same instance. The logic framework that corresponds to Propositional Logic with these two additions is known as Many-Sorted First Order Logic (MSFOL). The semantics of this logic is given in detail in~\cite{many_sorted}. In Section~\ref{sec:msfolHere} we give a brief overview of it.

% EXAMPLE -- remove?

% For instance, let $x$ and $y$ be integer variables and the symbols $+$ and $<$ have their usual meaning of addition and comparison of integers. Then, consider the formula:

% \begin{center}
%   $0 < x \land x < 2 \land (\forall z . (y < z) \lor x + y < 1 + y)$
% \end{center}

% By the first two propositions we can derive that $x = 1$. But if $x = 1$ then $x + y$ can't be lesser than $1 + y$. Also, it is impossible to choose a value for $y$ such that $\forall z . (y < z)$. Therefore, there is no value for $x$ and $y$ that would satisfy the whole formula. In other words, it is unsatisfiable. On the other hand, the following formula is satisfied by assigning, for instance, $x = 0$ and $y = 3$:

% \begin{center}
%   $-1 < x \land x < 1 \land (\forall z . (y < z) \lor x + y < 1 + y)$
% \end{center}

% END EXAMPLE

% tem que falar o que eh uma demonstracao nesse contexto antes de falar isso
% Some of the most relevant theories in SMT are Linear Integer Arithmetic (LIA), Linear Real Arithmetic (LRA), Bitvectors (BV) and Equality and Uninterpreted Functions (EUF).
% In this work, we will focus on reconstructing proofs from LIA, LRA, EUF and regular SAT proofs of unsatisfiability.


\subsection{Many-Sorted First Order Logic}\label{sec:msfolHere}

define formarly many sorted first order logic

talk about fixing the meaning of some theories to improve performance

skipping this for now, I will write the rest of the thesis so I have a better understanding of what needs to go here

\subsection{Applications}

Given a program and a formal specification of some property related to the program, it is often \tom{always?} the case that we can express the proposition that asserts that the program satisfy the property as an SMT instance. For instance, consider the well known \textit{abs} function, that takes an integer and returns its absolute value. The usual way to implement it is through a branch that checks whether the input variable is positive or negative. In case it is positive, its own value is returned. Otherwise, the value multiplied by $-1$ is returned:

\begin{algorithm}
\caption{Original Absolute Function}~\label{originalAbs}
\begin{algorithmic}
\Function{abs}{x}
\If{$x < 0$}
  \State\Return$-x$
\Else
  \State\Return$x$
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

In program analysis, it is quite useful to eliminate branches from programs since this action completely removes one possible path that the flow of the program can take (besides optimizing it's performance). Obviously, this operation must be done with caution to not modify the original behavior of the program. In his book~\cite{hacker_delight}, Henry Warren proposes an alternative implementation for the \textit{abs} function which doesn't have branches:

\begin{algorithm}
\caption{Branchless Absolute Function}~\label{branchlessAbs}
\begin{algorithmic}
\Function{abs'}{x}
  \State $y \gets x >> 31$
  \State \Return $(x \bigoplus y) - y$
\EndFunction
\end{algorithmic}
\end{algorithm}

Where $\bigoplus$ represents the bitwise xor operation. We can design an instance of the SMT problem that asserts that both implementations produce the same output, when given the same input. We present the instance written in SMT-LIB~\cite{smtlib}, a standardized syntax for representing SMT problems:

\begin{minted}[linenos]{smtlib2.py -x}
(set-logic QF_BV)
(declare-const x (_ BitVec 32))
(declare-const result1 (_ BitVec 32))
(assert (= result1 (ite (bvslt x #x00000000) (bvneg x) x)))
(declare-const y (_ BitVec 32))
(declare-const result2 (_ BitVec 32))
(assert (= y (bvashr x (_ bv31 32))))
(assert (= result2 (bvsub (bvxor x y) y)))
(assert (distinct result1 result2))
(check-sat)
\end{minted}

First, we set the combination of theories that will be used in this problem. In our case, we will be using \textit{QF\_BV}, which stands for quantifier free bitvectors. This means that this instance of the problem is not allowed to use quantifiers and is allowed to declare and use variables living in the Bitvector sort, as well as operations over this sort. Bitvectors are fixed-length arrays of bits. They are useful for representing machine integers, as they can simulate their semantics.

Next, in lines 2 and 3, we define two constants, both from the sort \textit{BitVec 32} (arrays of 32 bits): \textit{x} and \textit{result1}. The first one represents the input value from the original \textit{abs} function, and the second one, the result produced by that function. We then have to add an assertion in line 4 that binds the variable \textit{result1} to the output of the function \textit{abs} in terms of \textit{x}. We translate the branch from the pseudocode as the \textit{ite} operator, the comparison as the \textit{bvslt} operator and the multiplication by -1 as the \textit{bvneg} operation. This assertion will be encoded as a regular implication from SAT, where the premiss is it's proposition and the conclusion is the rest of the problem, which still needs to be defined. In lines 5 to 8 we repeat the process to define \textit{y} and \textit{result2}, which corresponds to the result of the branchless \textit{abs} function. Finally, we assert that \textit{result1} and \textit{result2} must be different in line 9. If this problem is satisfiable, then there is a value for \textit{x} which produces different values in each function. If it is unsatisfiable, then we can be sure that no such value exists, therefore, both functions are equivalent. Note that we are not verifying that the actual code of the functions are equivalent, just an abstraction over it's implementation.

% Given that we have very efficient systems to solve such problems, which will be introduced later, the possibility of formally verifying programs using this technology is quite promising. Indeed, \tom{pegar referencias do paper do leonardo (https://fm.csl.sri.com/SSFT14/smt-application-chapter.pdf)}
%

% \begin{itemize}
%   \item revolucao sat
%   \item representar propriedades de programas como problemas smt
%   \item geracao de casos de teste
%   \item geracao de programas
%   \item F*, Dafny
% \end{itemize}


\subsection{SMT Solvers}

A SMT solver is a piece of software whose main goal is to solve the SMT problem. Many-Sorted First Order Logic is undecidable in it's most general form~\cite{fol_undec}, therefore SMT solvers have to limit themselves to use heuristics to solve the largest possible subset of instances of the problem. In this section we present the ideas used by these systems that are most relevant to the present work.

\subsubsection{DPLL}

First, letâ€™s explore how SAT is solved. Although MSFOL is not decidable, Propositional Logic is, therefore, it is possible to design a decision procedure for SAT.\@ Indeed, one simple way to check whether a formula in PL with $n$ variables is satisfiable or not is to simply test each one of the $2^{n}$ functions assigning truth values to those variables.

A more efficient alternative of a decision procedure for PL is the DPLL algorithm~\cite{dpll}. DPLL is based on the \textit{Resolution} theorem:

\begin{theorem}[Resolution]
Let $x$ be a literal. Let $C_{1}$ and $C_{2}$ be two clauses such that $x \in C_{1}$ and $\overline x \in C_{2}$. Then $C_{1} \wedge C_{2} \rightarrow (C_{1} \setminus x) \vee (C_{2} \setminus \overline x)$.
\end{theorem}

More specifically, it is based on \textit{Unit Resolution} (UR), that is, a more specific version of Resolution in which $C_{1} = \{x\}$ or $C_{2} = \{\overline x\}$. We present DPLL's pseudocode and a brief explanation over it:

\begin{algorithm}[H]
\caption{DPLL Algorithm}~\label{dpllAlgo}
% \hspace*{\algorithmicindent} \textbf{Input:} $\psi$, a formula in CNF \\
% \hspace*{\algorithmicindent} \textbf{Output:} \textit{true} or \textit{false}, depending whether $\psi$ is satisfiable
\textbf{Input:} $\psi$, a PL formula\\
\textbf{Output:} \textit{true} or \textit{false}, depending whether $\psi$ is satisfiable
\begin{algorithmic}
\Function{SolvePL}{$\psi$}
\State $\psi \gets \Call{ConvertCNF}{\psi}$
\If{$\exists C \in \psi .\, C = \{\bot\}$}
  \State \Return~\textit{false}
\ElsIf{$\forall C \in \psi .\, \top \in C$}
  \State \Return~\textit{true}
\Else
  \If{$\exists x \in Vars(\psi) \,$ such that $x$ is a target for UR}
    \State $\langle C_{1}, C_{2} \rangle \gets$ \Call{findClauses}{$x$, $\psi$} \Comment{Clauses suitable for applying UR with $x$}
    \State~\Return~\Call{SolvePL}{$\psi \cup C_{1} \diamond_{x} C_{2}$}
  \Else
    \State~Let $x$ be an unassinged variable in $\psi$
    \State~\Return~\Call{SolvePL}{$\psi_{\{x \gets \top\}}$} $\vee$ \Call{SolvePL}{$\psi_{\{x \gets \bot\}}$}
  \EndIf
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

The algorithm works as follows: first, it checks to see if the formula can be evaluated to \textit{true} or \textit{false}. In case it can't, the procedure finds as many variables in which it can apply Unit Resolution as possible, calling itself recursively with each new application found. By the resolution theorem, the formula that will be used as a parameter in the recursive call is satisfiable if and only if the one that was received by input is also satisfiable, therefore, this step is sound. Once there are no more possibilities, it chooses an arbitrary variable and make two recursive calls: one assigning this variable to \textit{true} and the other one to \textit{false}. Since these are the only two possibilities for that variable, the input formula is satisfiable if and only if one of the recursive calls returned \textit{true}. The algorithm uses this information to correctly return the disjunction between the two return values.

The actual algorithm used by most SMT solvers is a refinement over DPLL, called CDCL~\cite{cdcl}.\ Since this refinement is not relevant for this work, we will not present it here.

\subsubsection{DPLL(T)}

DPLL(T) is an abstract framework based on the DPLL algorithm that is used as a basis for solving the SMT problem. This is the solution that most SMT solvers actually implement for solving the problem. Consider a formula $\psi$ over a theory $\mathcal{T}$ in MSFOL.\ Let's assume we have a solver for this theory (that is, a method for deciding whether a given set of propositions in $\mathcal{T}$ is consistent or not). The idea behind DPLL(T) is to create a PL formula $\psi'$ from $\psi$ by substituting each atom in it for a fresh boolean variable. We can then use the previously described DPLL algorithm to determine whether $\psi'$ is satisfiable. If it is unsatisfiable, then $\psi$ is also unsatisfiable. Otherwise, we can find a model $M$ for $\psi'$. Although $M$ satisfies $\psi'$, it is possible that it contradicts some fact about $\mathcal{T}$. For instance, consider $\psi$ to be the formula $x > 3 \wedge x < -2$. From it, we would generate the PL formula $p \wedge q$, where $p$ represents $x > 3$ and $q$ represents $x < -2$. The only possible model for this formula is the one that assigns both $p$ and $q$ to $\top$, but this is not valid when we translate back to $\psi$, as $x$ cannot be both greater than $3$ and smaller than $-2$. If this happens, we rely on the theory solver to provide a new lemma from $\mathcal{T}$ that shows why the previous assignment was invalid. In this case, it would provide the lemma $\neg (x > 3 \wedge x < -2)$.


\begin{algorithm}[H]
\caption{DPLL(T) Algorithm}~\label{dpllTAlgo}
    \hspace*{\algorithmicindent} \textbf{Input:} $\psi$, a formula in MSFOL over a theory  $\mathcal{T}$ \\
    \hspace*{\algorithmicindent} \textbf{Output:} \textit{true} or \textit{false}, depending whether $\psi$ is satisfiable
\begin{algorithmic}
\Function{SolveMSFOL}{$\psi$}

\State $\psi' \gets \Call{Convert}{\psi}$
\If{$\Call{SolvePL}{\psi'}$}
  \State $M \gets \Call{GetModel}{\psi'}$
  \State $L \gets \Call{TheorySolver}{M, \psi}$
  \If{$L = \varnothing$}
    \State~\Return \textit{true}
  \Else
    \State~\Return $\Call{SolveMSFOL}{\psi \cup L}$
  \EndIf
\Else
  \State~\Return \textit{false}
\EndIf


\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Congruence Closure}

\begin{itemize}
  \item Dar a definicao formal de EUF
  \item Explicar o que eh o congruence closure
  \item Explicar o algoritmo com union find pra resolver
\end{itemize}

\subsubsection{Linear Arithmetic}


\subsection{Proofs in cvc5}
