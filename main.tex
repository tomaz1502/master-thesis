\documentclass[
	msc,
	english
%% Para dissertações de mestrado, OU
%	mscproposta, %% Para propostas de dissertação de mestrado, OU
%	phd, %% Para teses de doutorado, OU
%	phdproposta, %% Para propostas de tese de doutorado
%	portugues %% Para documentos em português, OU
%	english %% Para documentos em inglês
]{ppgccufmg}

%\usepackage[brazil]{babel} %% se o documento for em português, OU
\usepackage[english]{babel} %% se o documento for em inglês
%\usepackage[latin1]{inputenc}
\usepackage{natbib}
\usepackage{xcolor}
\usepackage{lipsum}
\usepackage[hyphens]{url}
\usepackage[
	colorlinks=true,
	linkcolor=blue, %% Cor dos links do sumário
	citecolor=red, %% Cor dos links das citações      
	urlcolor=magenta, %% Cor das urls
]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[toc]{glossaries}
\usepackage{glossaries-extra}
\usepackage{bm}
\usepackage{tikz}
\usepackage{relsize}
\usepackage[normalem]{ulem}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amsthm}
% \usepackage[proofrulebaseline=2ex]{prooftrees}
\usepackage{appendix}
\usepackage{longtable, tabu}
\usepackage{makecell}
% \usepackage{cite}
%% Exemplo de lista customizada ==================
%% Para criar uma lista customizada (como Lista de Algoritmos, Lista de Exemplos) que ficará juntamente com as Lista de Figuras e Lista de Tabelas, execute os 3 comandos abaixo substituindo "algoritmos" pelo tipo de lista que estará criando. Para adicionar a lista ao documento, deverá passar o seguinte parâmetro no comando \ppgccufmg:
%% \ppgccufmg{
%% 		...
%% 		listacustomizada={\listadealgoritmos}
%% }
% \newfloat[chapter]{algoritmo}{lol}{Algoritmo}
% \newcommand{\listaalgoritmosname}{Lista de Algoritmos} %% Título da lista
% \newlistof{listadealgoritmos}{lol}{\listaalgoritmosname} %% O primeiro parâmetro é o nome da lista, e este deverá ser passado no parâmetro listacustomizada={\nomedalista}
% \newlistentry{algoritmo}{lol}{0} %% Nome do ambiente de cada algoritmo, e.g., \begin{algoritmo} ... \end{algoritmo}

%% **** Caso não haja nenhuma lista adicional, os comandos acima podem ser apagados. ****
%% ===============================================

\DeclareUnicodeCharacter{2265}{$\ge$}
\DeclareUnicodeCharacter{2227}{$\wedge$}
\DeclareUnicodeCharacter{2243}{$\simeq$}
\DeclareUnicodeCharacter{2264}{$\mathbb{\le}$}
\DeclareUnicodeCharacter{2200}{$\mathbb{\forall}$}
\DeclareUnicodeCharacter{2228}{$\vee$}
\DeclareUnicodeCharacter{2084}{$_{4}$}
\DeclareUnicodeCharacter{2083}{$_{3}$}
\DeclareUnicodeCharacter{2082}{$_{2}$}
\DeclareUnicodeCharacter{2081}{$_{1}$}
\DeclareUnicodeCharacter{208A}{$_{+}$}
\DeclareUnicodeCharacter{1D62}{$_{i}$}
\DeclareUnicodeCharacter{208B}{$_{-}$}
\DeclareUnicodeCharacter{03B1}{$\alpha$}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}

\newcommand{\yell}[1]{{\color{blue} [#1]}}
\newcommand{\tom}[1]{\yell{#1 --tom}}

% \newglossarystyle{mystyle}{%
%   \glossarystyle{long}%
%   \renewenvironment{theglossary}%
%      {\begin{longtable}{p{3cm}p{\glsdescwidth}}}%
%      {\end{longtable}}%
% }

% \newglossary{symbols}{sym}{sbl}{List of Symbols}
% \makeglossaries
% % \newglossaryentry{NegLit}
% % {
% %     name = {$\bm{\overline x}$ },
% %     description={Negation of the literal $x$}
% % }
% \newglossaryentry{IncVar}
% {
%   name = {$\bm{x \in C}$ },
%   description={Variable $x$ is present in the clause $C$}
% }
% \newglossaryentry{RemVar}
% {
%   name = {$\bm{C \setminus x}$ },
%   description={Clause $C$ without variable $x$}
% }
% \newglossaryentry{FormulaVars}
% {
%   name = {$\bm{\textit{Vars}(\psi)}$ },
%   description={Set of all variables in the formula $\psi$}
% }
% \newglossaryentry{Resolution}
% {
%   name = {\bm{$C_{1} \diamond_{x} C_{2}$} },
%   description={Clause resulting from applying resolution with $C_{1}$ and $C_{2}$ using $x$ as a pivot}
% }
% \newglossaryentry{VarAssign}
% {
%   name = {$\bm{\psi_{\{x \gets val\}}$} },
%   description = {Formula resulting of assigning the variable $x$ to the boolean value $val$ in $\psi$}
% }

\begin{document}
	\ppgccufmg{
		autor={Tomaz Mascarenhas}, %% Autor(a)
		titulopt={Demonstrando teoremas em Lean por meio da reconstrução de demonstra\c{c}\~oes em SMT},
		tituloen={Proving Lean theorems via reconstructed SMT proofs}, %% Título em inglês
		cidade={Belo Horizonte},
		ano={2023},
		versaopt={Final},
		versaoen={Final}, %% Palavra que acompanhará 'Version' na folha de rosto em inglẽs
		orientador={Haniel Barbosa}, %% Para masculino
		% fichacatalografica={fichacatalografica.pdf},
		folhadeaprovacao={folhadeaprovacao.pdf},
		resumo={resumo.tex}, %% Resumo em português
		palavraschave={Verifica\c{c}\~ao Formal, Lean, SMT},
		abstracten={abstract.tex}, %% Abstract em inglês
		keywords={Formal Verification, Lean, SMT}, %% Palavras-chave do abstract
		% dedicatoria={dedicatoria.tex}, %% Arquivo .tex contendo a dedicatória
		agradecimentos={agradecimentos.tex},
		epigrafe={The road to wisdom? Well, it's plain
and simple to express:
err
and err
and err again,
but less
and less
and less.},
		epigrafeautor={Piet Hein},
		% listadefiguras={sim}, %% Remova (ou comente) este parâmetro para remover a lista de figuras
		% listadetabelas={sim}, %% Remova (ou comente) este parâmetro para remover a lista de tabelas
		% listascustomizadas={\listadealgoritmos} %% Lista customizada (e.g., lista de algoritmos).
	}

  %   \printunsrtglossary %[style=mystyle]

	% \newpage

	\tableofcontents

	\chapter{Introduction}
	    \input{Chapters/Introduction/Context}
	  \section{Contributions}
	    \input{Chapters/Introduction/Contributions}
	  \section{Related work}\label{sec:related}
	    	\input{Chapters/Introduction/RelatedWork/HammeringTowards}
	    \subsection{SMTCoq}
           \label{sec:smtcoq}
	    	\input{Chapters/Introduction/RelatedWork/Coq}
	    \subsection{Sledgehammer}
           \label{sec:sledgehammer}
	    	\input{Chapters/Introduction/RelatedWork/Sledgehammer}
	  \section{Organization of this document}
	    \input{Chapters/Introduction/Organization}
	\chapter{Formal Preliminaries}\label{chap:formalPrelim}
      \section{Satisfiability Modulo Theories (SMT)}\label{sec:smt}
        \input{Chapters/FormalPreliminaries/SMT}
    \section{Lean}
        \input{Chapters/FormalPreliminaries/Lean}
    \chapter{Certified Transformations}\label{chap:certified}
    \input{Chapters/ProofReconstruction/pre.tex}
      % \section{Proof format}\label{sec:pf_format}
      %   \input{Chapters/ProofReconstruction/generatingScripts.tex}
      \section{Proof reconstruction}\label{sec:certified_rcons}
        \input{Chapters/ProofReconstruction/certified.tex}
    \chapter{Certifying Transformations}\label{chap:rcons}
        \input{Chapters/ProofReconstruction/certifying.tex}
	\chapter{Evaluation}\label{chap:eval}
      \input{Chapters/Evaluation.tex}
	\chapter{Future Work}\label{chap:future}
      \input{Chapters/Future.tex}

    \appendix
    \chapter{Complete list of theorems and tactics}

    Note: throughout the rules, assume that \texttt{p}, \texttt{q} and \texttt{r}
    are ranging over \texttt{Prop}, \texttt{l} over \texttt{List Prop}, \texttt{perm}
    over \texttt{List Nat} and \texttt{a} and \texttt{b} are ranging over either  \texttt{Int}
    or \texttt{Rat}

% \renewcommand\theadalign{bc}
% \renewcommand\theadfont{\bfseries}
% \renewcommand\theadgape{\Gape[4pt]}
% \renewcommand\cellgape{\Gape[4pt]}

% \centering
\begin{longtabu} to \textwidth { l l l }
\toprule
Name        & Statement & Implementation \\ \midrule
\texttt{notImplies1} & \texttt{¬ (p → q) → p} & theorem \\ \midrule
\texttt{notImplies2} & \texttt{¬ (p → q) → ¬ q}      & theorem        \\ \midrule
\texttt{equivElim1}  & \texttt{p = q → ¬ p ∨ q}      & theorem        \\ \midrule
\texttt{equivElim2}  & \texttt{p = q → p ∨ ¬ q}      & theorem        \\ \midrule
\texttt{notEquivElim1}  & \texttt{¬ (p = q) → p ∨ q}  & theorem        \\ \midrule
\texttt{notEquivElim2}  &  \texttt{¬ (p = q) → ¬ p ∨ ¬ q}      & theorem        \\ \midrule
\texttt{iteElim1} & \texttt{ite p q r → ¬ p ∨ q} & theorem \\ \midrule
\texttt{iteElim2} & \texttt{ite p q r → p ∨ r} & theorem \\ \midrule
\texttt{notIteElim1} & \texttt{¬ ite p q r → ¬ p ∨ ¬ q} & theorem \\ \midrule
\texttt{notIteElim2} & \texttt{¬ ite p q r → p ∨ ¬ r} & theorem \\ \midrule
\texttt{contradiction} & \texttt{p → ¬ p → False} & theorem \\ \midrule
\texttt{orComm} & \texttt{p ∨ q → q ∨ p} & theorem \\ \midrule
\texttt{orAssoc} & \texttt{p ∨ q ∨ r → (p ∨ q) ∨ r} & theorem \\ \midrule
\texttt{orAssocConv} & \texttt{p ∨ (q ∨ r) → p ∨ q ∨ r} & theorem \\ \midrule
\texttt{congOrRight} & \texttt{(p → q) → p ∨ r → q ∨ r} & theorem \\ \midrule
\texttt{congOrLeft} & \texttt{(p → q) → r ∨ p → r ∨ q} & theorem \\ \midrule
\texttt{orImplies} & \texttt{(¬ p → q) → p ∨ q} & theorem \\ \midrule
\texttt{orImplies₂} & \texttt{¬ p ∨ q → (p → q)} & theorem \\ \midrule
\texttt{orImplies₃} & \texttt{p ∨ q → (¬ p → q)} & theorem \\ \midrule
\texttt{scope} & \texttt{(p → q) → ¬ p ∨ q} & theorem \\ \midrule
\texttt{impliesElim} & \texttt{(p → q) → ¬ p ∨ q} & theorem        \\ \midrule
\texttt{deMorganSmall} & \texttt{¬ (p ∨ q) → ¬ p ∧ ¬ q}      & theorem        \\ \midrule
\texttt{deMorganSmall₂} & \texttt{¬ p ∧ ¬ q → ¬ (p ∨ q)}      & theorem        \\ \midrule
\texttt{deMorganSmall₃} & \texttt{¬ (p ∧ q) → ¬ p ∨ ¬ q}      & theorem        \\ \midrule
\texttt{notNotElim} & \texttt{¬ (¬ p) → p}      & theorem        \\ \midrule
\texttt{notNotIntro} & \texttt{p → ¬ (¬ p)} & theorem        \\ \midrule
\texttt{deMorgan} & \texttt{¬ orN (notList l) → andN l} & theorem        \\ \midrule
\texttt{deMorgan₂} & \texttt{andN l → ¬ orN (notList l)}      & theorem        \\ \midrule
\texttt{deMorgan₃} & \texttt{¬ orN l → andN (notList l)}      & theorem        \\ \midrule
\texttt{cnfAndNeg} & \texttt{andN l ∨ orN (notList l)}      & theorem        \\ \midrule
\texttt{cnfAndPos} & \texttt{¬ (andN l) ∨ l.getD i True}      & theorem        \\ \midrule
\texttt{cnfOrNeg} & \texttt{orN l ∨ ¬ l.getD i False}      & theorem        \\ \midrule
\texttt{cnfOrPos} & \texttt{¬ (orN l) ∨ orN l}      & theorem        \\ \midrule
\texttt{cnfImpliesPos} & \texttt{¬ (p → q) ∨ ¬ p ∨ ¬ q} & theorem \\ \midrule
\texttt{cnfImpliesNeg1} & \texttt{(p → q) ∨ p}      & theorem        \\ \midrule
\texttt{cnfImpliesNeg2} & \texttt{(p → q) ∨ ¬ q} & theorem        \\ \midrule
\texttt{cnfEquivPos1} & \texttt{¬ (p = q) ∨ ¬ p ∨ q}      & theorem        \\ \midrule
\texttt{cnfEquivPos2} & \texttt{¬ (p = q) ∨ p ∨ ¬ q}      & theorem        \\ \midrule
\texttt{cnfEquivNeg1} & \texttt{(p = q) ∨ p ∨ q}      & theorem        \\ \midrule
\texttt{cnfEquivNeg2} & \texttt{(p = q) ∨ ¬ p ∨ ¬ q}      & theorem        \\ \midrule
\texttt{cnfItePos1} & \texttt{¬ (ite p q r) ∨ ¬ p ∨ q}      & theorem        \\ \midrule
\texttt{cnfItePos2} & \texttt{¬ (ite p q r) ∨ p ∨ r}      & theorem        \\ \midrule
\texttt{cnfItePos3} & \texttt{¬ (ite p q r) ∨ q ∨ r}      & theorem        \\ \midrule
\texttt{cnfIteNeg1} & \texttt{(ite p q r) ∨ ¬ p ∨ ¬ q}      & theorem        \\ \midrule
\texttt{cnfIteNeg2} & \texttt{(ite p q r) ∨ p ∨ ¬ r}      & theorem        \\ \midrule
\texttt{cnfIteNeg3} & \texttt{(ite p q r) ∨ ¬ q ∨ ¬ r}      & theorem        \\ \midrule
\texttt{iteIntro} & \makecell[l]{\texttt{ite p ((ite p q r) = q)} \\ \texttt{((ite p q r) = r)}} & theorem        \\ \midrule
\texttt{eqResolve} & \texttt{p → p = q → q}      & theorem        \\ \midrule
\texttt{dupOr} & \texttt{p ∨ p ∨ q → p ∨ q}      & theorem        \\ \midrule
\texttt{dupOr₂} & \texttt{p ∨ p → p}      & theorem        \\ \midrule
\texttt{andElim} & \texttt{andN l → l.getD i True}      & tactic        \\ \midrule
\texttt{notOrElim} & \texttt{¬ (orN l) → ¬ (l.getD i False)}      & tactic        \\ \midrule
\texttt{notAnd} & \texttt{¬ (andN l) → orN (notList l)} & theorem        \\ \midrule
\texttt{modusPonens} & \texttt{p → (p → q) → q}      & theorem        \\ \midrule
\texttt{trueIntro} & \texttt{p → p = True}      & theorem        \\ \midrule
\texttt{trueElim} & \texttt{p = True → p}      & theorem        \\ \midrule
\texttt{trueElim₂} & \texttt{True = p → p}      & theorem        \\ \midrule
\texttt{falseIntro} & \texttt{¬ p → p = False}      & theorem        \\ \midrule
\texttt{falseIntro₂} & \texttt{¬ p → False = p}      & theorem        \\ \midrule
\texttt{falseElim} & \texttt{p = False → ¬ p}      & theorem        \\ \midrule
\texttt{falseElim₂} & \texttt{False = p → ¬ p}      & theorem        \\ \midrule
\texttt{negSymm} & \texttt{¬ (p = q) → ¬ (q = p)}      & theorem        \\ \midrule
\texttt{factor} & \texttt{orN l → orN (removeDuplicates l)}      & tactic        \\ \midrule
\texttt{liftOrNToImp} & \makecell[l]{\texttt{orN l → andN (take i (notList l))} \\ \texttt{ → orN (drop i l)}}      & tactic        \\ \midrule
\texttt{liftOrNToNeg} & \texttt{orN l → ¬ (andN l)} & tactic        \\ \midrule
\texttt{permutateClause} & \texttt{orN l → orN (permutate perm l)}      & tactic        \\ \midrule
\texttt{pull} & \makecell[l]{\texttt{orN l →} \\ \texttt{l.getD i False ∨ orN (eraseIdx i l)}}      & tactic        \\ \midrule
\texttt{R1} & \makecell[l]{\texttt{orN l₁ → orN l₂ →} \\ \texttt{orN ((erase p l₁) ++ (erase (¬ p) l₂))}}      & tactic        \\ \midrule
\texttt{R2} &  \makecell[l]{\texttt{orN l₁ → orN l₂ →} \\ \texttt{orN ((erase (¬ p) l₁) ++ (erase p l₂))}}     & tactic        \\ \midrule
\texttt{arithMulPos} & \texttt{m > 0 ∧ a < b → m * a < m * b}      & tactic        \\ \midrule
\texttt{arithMulNeg} & \texttt{m < 0 ∧ a < b → m * a > m * b}      & tactic        \\ \midrule
\texttt{tightLb} & \texttt{a < b → a ≤ (ceil b) - 1}      & tactic        \\ \midrule
\texttt{tightUb} & \texttt{a > b → a ≥ (floor b) + 1}      & tactic        \\ \midrule
\texttt{trichotomy} & \texttt{¬ (a < b) → ¬ (a = b) → a > b}      & tactic        \\
\bottomrule
\end{longtabu}\label{table:allRules}
% \end{table}
		%% Referências
		\bibliographystyle{plain}
		\bibliography{referencias}

\end{document}
